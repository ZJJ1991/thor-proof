export class Bytes {
    private static readonly isHex = /^[0-9a-f]*$/i

    static from(hex: string, prefix = '0x') {
        if (!hex.startsWith(prefix))
            throw new Error('prefix mismatch')

        hex = hex.substr(prefix.length)
        if (!Bytes.isHex.test(hex))
            throw new Error('not hex format')

        if (hex.length % 2 != 0) {
            throw new Error('odd hex')
        }
        return new Bytes(new Buffer(hex, 'hex'))
    }

    readonly buffer: Buffer
    constructor(buf: Buffer) {
        this.buffer = buf
    }

    toString(prefix = '0x') {
        return (prefix || '') + this.buffer.toString('hex')
    }

    trimLeft(v = 0) {
        let i = 0
        for (; i < this.buffer.length; i++) {
            if (this.buffer[i] != v)
                break
        }
        return new Bytes(this.buffer.slice(i))
    }
}

export class Address {
    static from(hex: string, prefix = '0x') {
        let bytes = Bytes.from(hex, prefix)
        if (bytes.buffer.length != 20)
            throw new Error("address should be 20 bytes")

        return new Address(bytes.buffer)
    }

    readonly buffer: Buffer
    constructor(buf: Buffer) {
        let newBuf = new Buffer(20)
        buf.copy(newBuf,
            newBuf.length > buf.length ? newBuf.length - buf.length : 0,
            buf.length > newBuf.length ? buf.length - newBuf.length : 0)
        this.buffer = newBuf
    }

    toString(prefix = '0x') {
        return (prefix || '') + this.buffer.toString('hex')
    }
}

export class Bytes32 {
    static from(hex: string, prefix = '0x') {
        let bytes = Bytes.from(hex, prefix)
        if (bytes.buffer.length != 32)
            throw new Error("bytes32 should be 32 bytes")

        return new Bytes32(bytes.buffer)
    }
    readonly buffer: Buffer
    constructor(buf: Buffer) {
        let newBuf = new Buffer(32)
        buf.copy(newBuf,
            newBuf.length > buf.length ? newBuf.length - buf.length : 0,
            buf.length > newBuf.length ? buf.length - newBuf.length : 0)
        this.buffer = newBuf
    }

    toString(prefix = '0x') {
        return (prefix || '') + this.buffer.toString('hex')
    }
}

import { BigNumber } from 'bignumber.js'

export class BigInt {
    static from(v: number | string | BigNumber) {
        let bn: BigNumber
        if (typeof v === 'string') {
            bn = new BigNumber(v)
        } else if (typeof v === 'number') {
            bn = new BigNumber(v)
        } else {
            bn = v
        }
        if (!bn.isInteger()) {
            throw new Error('not a integer')
        }
        let hex = bn.toString(16)
        if (hex.length % 2 != 0)
            hex = '0' + hex

        return new BigInt(new Buffer(hex, 'hex'))
    }
    readonly buffer: Buffer
    constructor(buf: Buffer) {
        this.buffer = new Bytes(buf).trimLeft().buffer
    }

    toBigNumber(): BigNumber {
        return new BigNumber(this.buffer.toString("hex"), 16)
    }

    toString(base: 16 | 10 = 16): string {
        let prefix = (base == 16) ? '0x' : ''
        return prefix + this.toBigNumber().toString(base)
    }
}
