import { Bytes, Address, BigInt, Bytes32 } from "./types"
import { ecrecover, blake2b256, ecsign } from './crypto'
const rlp = require('rlp')

export class Transaction {
    readonly body: Transaction.Body
    signature?: Bytes

    constructor(body: Transaction.Body) {
        validateBody(body)
        this.body = body
    }

    get signingHash() {
        let data = rlp.encode(rlpList(this.body))
        return blake2b256(data)
    }

    get id() {
        return blake2b256(
            this.signingHash.buffer,
            this.signer.buffer
        )
    }

    get signer() {
        if (!this.signature)
            throw new Error('signature missing')

        return ecrecover(this.signingHash, this.signature)
    }

    get intrinsicGas() {
        const txGas = 5000
        const clauseGas = 16000
        const clauseGasContractCreation = 48000

        if (this.body.clauses.length === 0)
            return txGas + clauseGas

        return this.body.clauses.reduce((sum, c) => {
            sum += dataGas(c.data.buffer)
            if (c.to)
                sum += clauseGas
            else
                sum += clauseGasContractCreation
            return sum
        }, txGas)
    }

    gasPrice(baseGasPrice: BigInt) {
        let bgp = baseGasPrice.toBigNumber()
        let extra = bgp
            .multipliedBy(this.body.gasPriceCoef)
            .dividedToIntegerBy(0xff)

        return BigInt.from(bgp.plus(extra))
    }

    sign(privateKey: Bytes32) {
        this.signature = ecsign(this.signingHash, privateKey)
    }

    encode() {
        if (!this.signature)
            throw new Error("signature missing")

        let list = rlpList(this.body)
        list.push(this.signature.buffer)
        let data = rlp.encode(list)
        return new Bytes(data)
    }

    static decode(raw: Bytes) {
        let list = decodeList(rlp.decode(raw.buffer), 10)

        let tx = new Transaction({
            chainTag: decodeNumber(list[0]),
            blockRef: new Bytes(decodeBigInt(list[1]).buffer),
            expiration: decodeNumber(list[2]),
            clauses: decodeClauses(list[3]),
            gasPriceCoef: decodeNumber(list[4]),
            gas: decodeBigInt(list[5]),
            dependsOn: decodeBytes32OrNull(list[6]),
            nonce: decodeBigInt(list[7]),
            reserved: decodeList(list[8])
        })
        tx.signature = new Bytes(decodeBuffer(list[9]))
        return tx
    }
}

export namespace Transaction {
    export type Clause = {
        to: Address | null
        value: BigInt
        data: Bytes
    }

    export type Body = {
        chainTag: number
        blockRef: Bytes
        expiration: number
        clauses: Clause[]
        gasPriceCoef: number
        gas: BigInt
        dependsOn: Bytes32 | null
        nonce: BigInt
        reserved: Bytes[]
    }
}

function decodeClauses(data: any) {
    return decodeList(data).map<Transaction.Clause>(v => {
        let clauseData = decodeList(v, 3)
        return {
            to: decodeAddressOrNull(clauseData[0]),
            value: new BigInt(decodeBuffer(clauseData[1])),
            data: new Bytes(decodeBuffer(clauseData[2]))
        }
    })
}

function rlpList(body: Transaction.Body): any[] {
    return [
        body.chainTag,
        body.blockRef.trimLeft().buffer,
        body.expiration,
        body.clauses.map(clause => {
            return [
                clause.to ? clause.to.buffer : "",
                clause.value.buffer,
                clause.data.buffer
            ]
        }),
        body.gasPriceCoef,
        body.gas.buffer,
        body.dependsOn ? body.dependsOn.buffer : "",
        body.nonce.buffer,
        body.reserved,
    ]
}

function validateBody(body: Transaction.Body) {
    mustUintN(body.chainTag, 8, 'chainTag: must be uint8')
    mustUintN(body.expiration, 32, 'expiration: must be uint32')
    mustUintN(body.gasPriceCoef, 8, 'gasPriceCoef: must be uint8')
    mustUintN(body.gas, 64, 'gas: must be uint64')

    if (body.blockRef.buffer.length > 8)
        throw new Error('blockRef: out of range')
    if (body.nonce.buffer.length > 8)
        throw new Error('nonce: out of range')
}

function mustUintN(num: number | BigInt, bit: number, msg: string) {
    if (typeof num === 'number') {
        if (!Number.isInteger(num) || num < 0 || num >= 2 ** bit)
            throw new Error(msg)
    } else {
        if (num.buffer.length * 8 > bit)
            throw new Error(msg)
    }
}


function decodeBigInt(data: any) {
    let buf = decodeBuffer(data)
    let bi = new BigInt(buf)
    if (bi.buffer.length != buf.length)
        throw new Error('non-canonical integer (leading zero bytes) for integer')
    return bi
}
function decodeNumber(data: any) {
    let bi = decodeBigInt(data)
    if (bi.buffer.length * 8 > 53)
        throw new Error('unable to safely decode to number')

    return bi.toBigNumber().toNumber()
}

function decodeBuffer(data: any) {
    if (!Buffer.isBuffer(data))
        throw new Error('buffer expected')
    return data
}

function decodeBytes32OrNull(data: any) {
    let buf = decodeBuffer(data)
    if (buf.length == 0)
        return null
    if (buf.length != 32)
        throw new Error('bytes32 expected')
    return new Bytes32(buf)
}

function decodeList(data: any, elemCount?: number) {
    if (!Array.isArray(data))
        throw new Error('list expected')

    if (elemCount !== undefined) {
        if (data.length !== elemCount)
            throw new Error('list element count incorrect')
    }
    return data
}

function decodeAddressOrNull(data: any) {
    let buf = decodeBuffer(data)
    if (buf.length == 0)
        return null
    if (buf.length != 20)
        throw new Error('address expected')

    return new Address(buf)
}

function dataGas(data: Buffer) {
    const zgas = 4
    const nzgas = 68

    return data.reduce((sum, cur) => {
        if (cur)
            return sum + nzgas
        return sum + zgas
    }, 0)
}