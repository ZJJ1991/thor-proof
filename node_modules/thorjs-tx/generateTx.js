const Fields = require('./fields')()
const ethUtil = require('ethereumjs-util')
function generateTx(_instance, data) {
  // verifyTxobj(data)

  Fields.forEach((item, i) => {
    function getter() {
      return _instance.raw[i]
    }

    function setter(v) {
      if (item.callback) {
        v = item.callback(v)
      } else {
        v = ethUtil.toBuffer(v)
        if (v.toString('hex') === '00' && !item.allowZero) {
          v = item.default
        } else if (item.allowLess && item.length) {
          v = ethUtil.stripZeros(v)
        } else if ((!item.length && !item.allowZero) || !v.length) {
          v = item.default
        }
      }
      _instance.fields[item.name] = v
      _instance.raw[i] = v
    }

    let options = {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    }

    Object.defineProperty(_instance, item.name, options)
  })

  let fields = Fields.map(item => {
    return item.name
  })
  fields.forEach(item => {
    _instance[item] = data[item]
  })
}

// function verifyTxobj(data) {
//   let _keys = Fields.map(item => {
//     return item.name
//   })
//   // console.log(_keys)
//   if (!Array.isArray(data) && typeof data === 'object') {
//     let keys = Object.keys(data)
//     console.log(keys)
//     if (!isKeysEqual(_keys, keys)) {
//       throw new Error('The tx params is invalid! Please check it.')
//     }
//   }
// }

// function isKeysEqual(k1, k2) {
//   let isok = k1.length === k2.length
//   k1.forEach(item => {
//     if (!k2.includes(item)) {
//       isok = false
//     }
//   })

//   return isok
// }

module.exports = generateTx
